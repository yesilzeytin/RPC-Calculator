/*
 * This is sample code generated by rpcgen
 * Modified by yesilzeytin for calculator
 */

#include "calc.h"
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

// Stack implementation source: https://www.techiedelight.com/stack-implementation/
// Data structure to represent a stack
struct stack
{
    int maxsize;    // define max capacity of the stack
    int top;
    int *items;
};
 
// Utility function to initialize the stack
struct stack* newStack(int capacity)
{
    struct stack *pt = (struct stack*)malloc(sizeof(struct stack));
 
    pt->maxsize = capacity;
    pt->top = -1;
    pt->items = (int*)malloc(sizeof(int) * capacity);
 
    return pt;
}
 
// Utility function to return the size of the stack
int size(struct stack *pt) {
    return pt->top + 1;
}
 
// Utility function to check if the stack is empty or not
int isEmpty(struct stack *pt) {
    return pt->top == -1;                   // or return size(pt) == 0;
}
 
// Utility function to check if the stack is full or not
int isFull(struct stack *pt) {
    return pt->top == pt->maxsize - 1;      // or return size(pt) == pt->maxsize;
}
 
// Utility function to add an element `x` to the stack
void push(struct stack *pt, int x)
{
    // check if the stack is already full. Then inserting an element would
    // lead to stack overflow
    if (isFull(pt))
    {
        printf("Overflow\nProgram Terminated\n");
        exit(EXIT_FAILURE);
    }
 
    printf("Inserting %d\n", x);
 
    // add an element and increment the top's index
    pt->items[++pt->top] = x;
}
 
// Utility function to return the top element of the stack
int peek(struct stack *pt)
{
    // check for an empty stack
    if (!isEmpty(pt)) {
        return pt->items[pt->top];
    }
    else {
        exit(EXIT_FAILURE);
    }
}
 
// Utility function to pop a top element from the stack
int pop(struct stack *pt)
{
    // check for stack underflow
    if (isEmpty(pt))
    {
        printf("Underflow\nProgram Terminated\n");
        exit(EXIT_FAILURE);
    }
 
    printf("Removing %d\n", peek(pt));
 
    // decrement stack size by 1 and (optionally) return the popped element
    return pt->items[pt->top--];
}

bool IsDigitsOnly(const char* str)
{
    for (int i = 0; i < strlen(str); i++)
    {
        if (str[i] < '0' || str[i] > '9')
            return false;
    }

    return true;
}

int
add_prog_1(char *host, int x, int y)
{
	CLIENT *clnt;
	int  *result_1;
	numbers  add_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, ADD_PROG, ADD_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	add_1_arg.a=x;
	add_1_arg.b=y;

	result_1 = add_1(&add_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else {
		printf("Result: %d\n", *result_1);
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return *result_1;
}


int
sub_prog_1(char *host, int x, int y)
{
	CLIENT *clnt;
	int  *result_1;
	numbers  sub_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, SUB_PROG, SUB_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	sub_1_arg.a=x;
	sub_1_arg.b=y;

	result_1 = sub_1(&sub_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else {
		printf("Result: %d\n", *result_1);
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return *result_1;
}


int
mul_prog_1(char *host, int x, int y)
{
	CLIENT *clnt;
	int  *result_1;
	numbers  mul_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, MUL_PROG, MUL_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	mul_1_arg.a=x;
	mul_1_arg.b=y;

	result_1 = mul_1(&mul_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else {
		printf("Result: %d\n", *result_1);
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return *result_1;
}


int
div_prog_1(char *host, int x, int y)
{
	CLIENT *clnt;
	int  *result_1;
	numbers  div_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, DIV_PROG, DIV_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	div_1_arg.a=x;
	div_1_arg.b=y;

	result_1 = div_1(&div_1_arg, clnt);
	if (result_1 == (int *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	else {
		printf("Result: %d\n", *result_1);
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
	return *result_1;
}


int
main (int argc, char *argv[])
{
	char *host;
	struct stack* stk = newStack(20);
	int tmp1, tmp2;

	if (argc < 5) {
		printf ("usage: %s server_host [expression without whitespace] [operation] [expression without whitespace]\n", argv[0]);
		exit (1);
	}
	host = argv[1];

	for (int i = 2; i < argc; i++) {
		if (!strcmp(argv[i], "+")) {
				tmp2 = pop(stk);
				tmp1 = pop(stk);
				push(stk, add_prog_1(host, tmp1, tmp2));
		}
		else if (!strcmp(argv[i], "-")) {
				tmp2 = pop(stk);
				tmp1 = pop(stk);
				push(stk, sub_prog_1(host, tmp1, tmp2));
		}
		else if (!strcmp(argv[i], "x")) {
				tmp2 = pop(stk);
				tmp1 = pop(stk);
				push(stk, mul_prog_1(host, tmp1, tmp2));
		}
		else if (!strcmp(argv[i], "/")) {
				tmp2 = pop(stk);
				tmp1 = pop(stk);
				push(stk, div_prog_1(host, tmp1, tmp2));
		}
		else if (IsDigitsOnly(argv[i])) {
				push(stk, atoi(argv[i]));
		}
		else {
			printf("Please enter a valid input and try again.\n");
			break;
		}
	}

	/*add_prog_1 (host, atoi(argv[2]), atoi(argv[3]));
	sub_prog_1 (host, atoi(argv[2]), atoi(argv[3]));
	mul_prog_1 (host, atoi(argv[2]), atoi(argv[3]));
	div_prog_1 (host, atoi(argv[2]), atoi(argv[3]));*/

exit (0);
}
